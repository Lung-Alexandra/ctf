Task 
```
So Sam and Mikaela told me why one big big prime is not enough.

Don't worry there all there and more now to improve security.

And since you all broke my beautiful system I only give you the output this time.

The flag is in this format: 4T${...}.
```

We got the following code 
```python
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from flags import FLAG_GAMGAM


def gen_key():
    p = getPrime(4096)
    n = 2*p
    e = 65537
    phi_n = (p - 1)
    d = pow(e, -1, phi_n)

    return (n, e), (n, d)


def encrypt(pt: int, pub_key: (int, int)) -> int:
    n, e = pub_key
    return pow(pt, e, n)


def decrypt(ct: int, priv_key: (int, int)) -> int:
    n, d = priv_key
    return pow(ct, d, n)


pt = bytes_to_long(FLAG_GAMGAM)
pub, priv = gen_key()

ct = encrypt(pt, pub)

print(pub)
print(ct)

""" output : 
pub = (1187036881143255678002463758823328059054967286304079946698830107983054756455116137560640360907617090768892222200232769013898086641365526920365941657223719909608623612364565491394396836689005779953582737606769612044152900984410189797945160970640233269434857215156707188226644140186233117418578999649675501923158500973527860820476774162258056088176836933971626651722297419469001832141393303687831763041541298637984981484605886538085054999743028130034186150375954369138007688335922353720290223733062752735362640330007395278113210621407774253326748367183647916542260385241849328645829055161868897760626313462053770486741600871918596910274170809764858924373557759944088849747488101309508664734646761762412297919300985341470183672896494363089287897564003884864937477882116184866139314943820121458541671053111784924614354354051278861337795171453392846554516472806170955424094756390970572454084554064299959563385403753982420758416150497980281277588694172034437436874006653172021381177623273333042379989422646166480734410913148567193586525237775287519085811109666011917375279015787726665088346364963313941503929463975682736763812440239892582271133388552728034109040233071519106207594592661468817905961569517921007110971395505830618097714478302, 65537)
ct = 795807804195143453698199351714341881491007858193124317249991960343873442402330541927355975462857321435938754440321580174443331666641181625664069405050964566344381744709294110771870536802353007022271867378658681771017152652337537847752445300535171488167996282441962543976576696465573991060306807268553659109840313328518099780850408480656440234846473549017585724141302898515099966486748289860601838615696366759534875502563433987281076478746704673766615604679732113066945172837918782569635525478298453073137252252807049842035005266808708242245205256476149494296039430508531375107451338401537609064664390446408507706477965483671800993119312002909135270398571898844908643483215653937390863031730605961379386046951618745731912613235578147115643378764728145934422515365821994913473759604466504627671738552946527189180057717976411101700962342930065732023681381389942592202841123754672836935980227561011259880242223658584675417448037977336301973044247690228389495603711704632306639520856078639797104835378636642939190389932673963835980987694812947833691746134338765367684261289851826492260573430796933048931658801423183863572727478714738535956082504958502080116828296338104460121704114347331800007862970894127699814246457589160922514051314061
"""

```

The provided code implements a version of RSA encryption, 
but it uses an unconventional method for generating the keys, 
which leads to an exploitable vulnerability. 

Normally, in RSA, the public modulus
`n` is the product of two distinct prime numbers `p` and `q`.
However, in this case, the modulus `n` is generated using only 
one prime `p`, by setting ` n = 2*p`.
This makes it much easier to recover the value of
`p` and decrypt the message.
We know `n` and `e` from `pub` provided in output.

## Steps to Solve

### 1. **Calculating `p`**

Since the modulus `n` is given as `n=2p`, we can easily compute `p` by dividing `n` by 2:
`p = n/2`

### 2. **Calculating &Phi;(n)**

Next, we compute &Phi;(n), the Euler's totient function for `n`. Since `n = 2p`, we can use the formula:
&Phi;(n) = p - 1

### 3. **Computing `d`**

The private key `d` is the modular inverse of `e` (the public exponent) 
modulo &Phi;(n). The value of `e` is provided as `65537`

d = e<sup>-1</sup> (mod &Phi;(n))

### 4. **Decrypting the Message**

Once we have `d`, we can decrypt the ciphertext `ct` using modular exponentiation:

pt = ct<sup>d</sup> (mod n)


### 5. **Extracting the Flag**

The decrypted message is in the form of a long integer, which is converted back into bytes to reveal the original flag.

## Python Code

```python
from Crypto.Util.number import long_to_bytes, inverse

# Given values from the problem
n = 1187036881143255678002463758823328059054967286304079946698830107983054756455116137560640360907617090768892222200232769013898086641365526920365941657223719909608623612364565491394396836689005779953582737606769612044152900984410189797945160970640233269434857215156707188226644140186233117418578999649675501923158500973527860820476774162258056088176836933971626651722297419469001832141393303687831763041541298637984981484605886538085054999743028130034186150375954369138007688335922353720290223733062752735362640330007395278113210621407774253326748367183647916542260385241849328645829055161868897760626313462053770486741600871918596910274170809764858924373557759944088849747488101309508664734646761762412297919300985341470183672896494363089287897564003884864937477882116184866139314943820121458541671053111784924614354354051278861337795171453392846554516472806170955424094756390970572454084554064299959563385403753982420758416150497980281277588694172034437436874006653172021381177623273333042379989422646166480734410913148567193586525237775287519085811109666011917375279015787726665088346364963313941503929463975682736763812440239892582271133388552728034109040233071519106207594592661468817905961569517921007110971395505830618097714478302
e = 65537
ct = 795807804195143453698199351714341881491007858193124317249991960343873442402330541927355975462857321435938754440321580174443331666641181625664069405050964566344381744709294110771870536802353007022271867378658681771017152652337537847752445300535171488167996282441962543976576696465573991060306807268553659109840313328518099780850408480656440234846473549017585724141302898515099966486748289860601838615696366759534875502563433987281076478746704673766615604679732113066945172837918782569635525478298453073137252252807049842035005266808708242245205256476149494296039430508531375107451338401537609064664390446408507706477965483671800993119312002909135270398571898844908643483215653937390863031730605961379386046951618745731912613235578147115643378764728145934422515365821994913473759604466504627671738552946527189180057717976411101700962342930065732023681381389942592202841123754672836935980227561011259880242223658584675417448037977336301973044247690228389495603711704632306639520856078639797104835378636642939190389932673963835980987694812947833691746134338765367684261289851826492260573430796933048931658801423183863572727478714738535956082504958502080116828296338104460121704114347331800007862970894127699814246457589160922514051314061

# Step 1: Compute p
p = n // 2

# Step 2: Compute φ(n)
phi_n = p - 1

# Step 3: Compute d (modular inverse of e mod φ(n))
d = inverse(e, phi_n)

# Step 4: Decrypt the ciphertext
pt = pow(ct, d, n)

# Step 5: Convert the decrypted plaintext to bytes
flag = long_to_bytes(pt)

print("Flag:", flag.decode())
```

Flag: `4T${one_to_rule_them_all}`
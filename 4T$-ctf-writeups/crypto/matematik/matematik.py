from Crypto.Util.number import long_to_bytes

# Taken from https://github.com/pablocelayes/rsa-wiener-attack
def hack_RSA(e, n):
    '''
    Finds d knowing (e,n)
    applying the Wiener continued fraction attack
    '''
    frac = rational_to_contfrac(e, n)
    convergents = convergents_from_contfrac(frac)

    for (k, d) in convergents:

        # check if d is actually the key
        if k != 0 and (e*d-1) % k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            # check if the equation x^2 - s*x + n = 0
            # has integer roots
            discr = s*s - 4*n
            if(discr >= 0):
                t = is_perfect_square(discr)
                if t != -1 and (s+t) % 2 == 0:
                    print("Hacked!")
                    return d


def rational_to_contfrac(x, y):
    '''
    Converts a rational x/y fraction into
    a list of partial quotients [a0, ..., an]
    '''
    a = x//y
    pquotients = [a]
    while a * y != x:
        x, y = y, x-a*y
        a = x//y
        pquotients.append(a)
    return pquotients


def convergents_from_contfrac(frac):
    '''
    computes the list of convergents
    using the list of partial quotients
    '''
    convs = []
    for i in range(len(frac)):
        convs.append(contfrac_to_rational(frac[0:i]))
    return convs


def contfrac_to_rational(frac):
    '''Converts a finite continued fraction [a0, ..., an]
     to an x/y rational.
     '''
    if len(frac) == 0:
        return (0, 1)
    num = frac[-1]
    denom = 1
    for _ in range(-2, -len(frac)-1, -1):
        num, denom = frac[_]*num+denom, num
    return (num, denom)


def egcd(a, b):
    '''
    Extended Euclidean Algorithm
    returns x, y, gcd(a,b) such that ax + by = gcd(a,b)
    '''
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a


def gcd(a, b):
    '''
    2.8 times faster than egcd(a,b)[2]
    '''
    a, b = (b, a) if a < b else (a, b)
    while b:
        a, b = b, a % b
    return a


def modInverse(e, n):
    '''
    d such that de = 1 (mod n)
    e must be coprime to n
    this is assumed to be true
    '''
    return egcd(e, n)[0] % n


def totient(p, q):
    '''
    Calculates the totient of pq
    '''
    return (p-1)*(q-1)


def bitlength(x):
    '''
    Calculates the bitlength of x
    '''
    assert x >= 0
    n = 0
    while x > 0:
        n = n+1
        x = x >> 1
    return n


def isqrt(n):
    '''
    Calculates the integer square root
    for arbitrary large nonnegative integers
    '''
    if n < 0:
        raise ValueError('square root not defined for negative numbers')

    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y >= x:
            return x
        x = y


def is_perfect_square(n):
    '''
    If n is a perfect square it returns sqrt(n),

    otherwise returns -1
    '''
    h = n & 0xF  # last hexadecimal "digit"

    if h > 9:
        return -1  # return immediately in 6 cases out of 16.

    # Take advantage of Boolean short-circuit evaluation
    if (h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8):
        # take square root if you must
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1

    return -1


n = 813291308603414089290668124041839733918488102866707584478634305319455045742732398934285162590313628856151815805790620427282606419733953720940672900768927843456798354736166539116245629511099027050834359384831529357375361650207922031319202531732346130779684513880916453362321181490895712150208665938936278172640305188677018153679323752530891790061335976403796874283838241633986457526745812030002471049604945974200148937982826320771554655435614757483499493911336752954800985578910845367956516996617229558390523818494709361186658914477419251812995871366351489494308292606000804614366845051918199227844254546329541843568318237109632457847134885083162397820112825732852216955328660838562813889545261894305894160609220887968790944587321188098754603643013421664631133010093611556497233001653201895232543427082211683021364712220647876947616554074640514028751536406658385579193774470930187879078899695146964706436953032128385848122414086434213809075484348842559074698856998042069709556057058143190691596178593402659233400344987806988713656452553047776818230138111821734002434933579554120175239589824745274138505528074316535235675310159751338868381402667299087497293471199173475186425479086169119058202621574904341235785246634876364612171762039
e = 507629470812273261823426390546598338984395989442071474050416785320440010159634016383832635630627366973849528238182510962137111640508110790495315940357236952175068500887330221534610953600273841963487815952694025077621388297338394497587374864453412549069891512740981002243575242455039752608668327752194980276553830616717081535140131472469003490922930873685871639979453889383771636442013652167366168345651503969931023708386430496255530725148293969510474787981494451982469823070955933396841763617850694834638657960004417960227867460846597255166692801940250504317372628474735332077991643792461076896124636935163284072466415339475869348991747659374068270652923128794611435079728489232122948179139197547105159952184231485291647613944223516450080883783540351500360106831879612194331391872641037161673244469591268235189667939691167302161427391206555938078520320564149433927306713056434689300750584217302607803804849162996945453960388589576433514450931587322042461589005902688639249894585367101942527518672906958428684989901046887818040748667377553642721872919254441104379963680746321602265998423512578545469859243244107381159471514440291591999221623568031461898015393860750228229154460555520746111342574014851882064314878187293289220899929807
ct = 556929789932718354289291849394616085746017472924699209648914037202503416575540852830970664161255326023268634267454107774965420213413821042576276508575455454361523573097884468178170003077347056594772266618658709362255877582064457508199710666562370947380840565162429512173936308204532454076794768514066924004746803038256412552237658292113081608006251236076708578344122432586668187584141207615427828061411854105828515375964545783967241743237338987432939077584028379144738368932124095367932978939269991855150473979077827471523074357255458371128658173282444008289098805775210188129191929555599684770996221844343085502091025637291770521228572273689936242153064802513056303923914150604670956717223303806593746367470261209586104020700589223881827015327135689001439309533530597224229719728250381029314935622264783085597813127891143325840103161823613658376562092838968353695725179031099723570207527561818677173920140026394852719332897635673091839874217580098458961022224756236920496049672662910077320373061540661712874310205443131382764229256203955927297599654747525835793142357208317882463486124468731953065393841513854916505999541748109264234674614040515601134746212095952825656454587128065358700074118271602538129048748869380854865933904021

d = hack_RSA(e, n)
print("d:{d}")
if d:
    #decript message
    pt = pow(ct, d, n)
    flag = long_to_bytes(pt)
    print("Flag-ul este:", flag)